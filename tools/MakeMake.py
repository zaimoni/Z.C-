#!/usr/bin/python

# http://www.boost.org/more/license_info.html
# Boost Software License - Version 1.0 - August 17th, 2003

# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:

# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# backward fixup note
# old version of configuring *.exe objects was
# ObjfileTuple = ('main','Mockup','Agent','render_curses')
# ProgName = 'Skirmish'
# 
# This didn't work well for Z.C++.  New style is
# ProgObjects = {'Skirmish':('main','Mockup','Agent','render_curses')}

from string import join
from os import stat,getcwd
from os.path import isfile

# compiler configuration
# this should be invariant for a given installation; note POSIX convention even on Windows
C_compiler_master_directory = 'C:/MingWin'
C_compiler = 'gcc'
C_system_includedirs = [C_compiler_master_directory+'/include']
C_system_libdirs = [C_compiler_master_directory+'/lib']
CPP_compiler = 'g++'
CPP_system_includedirs = [C_compiler_master_directory+'/include',C_compiler_master_directory+'/include/c++/3.4.5']
C_backtrack_dirs = []

def InjectAlternateSystemHeaderDir(Dirname):
	C_system_includedirs.append(Dirname)
	C_soft_nonsystem_includedirs.append(Dirname)	

execfile('MakeMake.cfg')

HeaderCache = {}

def SimplePOSIXConcatenate(RefDirname,Filename):
	if (RefDirname in frozenset(['${srcdir}','$(srcdir)'])):
		sep_index = Filename.find('/')
		if -1<>sep_index:
			return Filename[sep_index+1:]
		return Filename
	if ('../'==Filename[0:3]):
		sep_index = RefDirname.rfind('/')
		if -1<>sep_index:
			return SimplePOSIXConcatenate(RefDirname[:sep_index],Filename[3:])
		else:
			return Filename[3:]		
	return RefDirname+'/'+Filename

def IsSystemInclude(Target):
	if isfile(Target):
		return 0
	if C_system_includedirs:
		for Prefix in C_system_includedirs:
			if isfile(SimplePOSIXConcatenate(Prefix,Target)):
				return 1
	if CPP_system_includedirs:
		for Prefix in CPP_system_includedirs:
			if isfile(SimplePOSIXConcatenate(Prefix,Target)):
				return 1
	sep_index = Target.find('/')
	if -1<>sep_index:
		return IsSystemInclude(Target[sep_index+1:])
	return 0

def RemapFile(Target):
	if isfile(Target):
		return Target

#	backup search paths..do both non-system includes and system includes
	if C_hard_nonsystem_includedirs:
		for Prefix in C_hard_nonsystem_includedirs:
			TestFilepath = SimplePOSIXConcatenate(Prefix,Target)
			if isfile(TestFilepath):
				return TestFilepath
	if C_soft_nonsystem_includedirs:
		for Prefix in C_soft_nonsystem_includedirs:
			TestFilepath = SimplePOSIXConcatenate(Prefix,Target)
			if isfile(TestFilepath):
				return TestFilepath

	if C_backtrack_dirs:
		for Prefix in C_backtrack_dirs:
			if 0<Target.find('/'+Prefix+'/'):
				return RemapFile(Target[Target.find('/'+Prefix+'/')+1:])

	return Target

def ExtractHeaders(Target):
	global HeaderCache
	if HeaderCache.has_key(Target):
		return HeaderCache[Target]
	if IsSystemInclude(Target):
		return []

	Target = RemapFile(Target)
	if not isfile(Target):
		print 'Warning: '+Target+' not found'
		return []

	HeaderCache[Target] = []

	RefDirname = '';
	sep_index = Target.rfind('/')
	if -1<>sep_index:
		RefDirname = Target[0:sep_index]

	TargetFile = open(Target,'r')
	LineList = TargetFile.readlines()
	TargetFile.close()
	LineList = filter(lambda x: x.startswith('#include '),LineList)
	LineList = filter(lambda x: -1!=x.find('"'),LineList)
	LineList = map(lambda x: x[x.find('"')+1:],LineList)
	LineList = map(lambda x: x[:x.find('"')],LineList)
	if RefDirname:
		LineList = map(lambda x: SimplePOSIXConcatenate(RefDirname,x),LineList)
	LineList = map(RemapFile,LineList)

	LineList2 = [];
	for TestFile in LineList:
		if TestFile not in LineList2:
			LineList3 = ExtractHeaders(TestFile)
			for TestFile2 in LineList3:
				if TestFile2 not in LineList2 and TestFile2 not in LineList:
					LineList.append(TestFile2)
			if LineList3 or not IsSystemInclude(TestFile):
				LineList2.append(TestFile)
	HeaderCache[Target] = LineList2
	return LineList2
	
def CoreCPPRules(LineList):
#	if C_hard_nonsystem_includedirs:
#		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_hard_nonsystem_includedirs),' ') +' -I- \\\n')
#	if C_soft_nonsystem_includedirs:
#		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_soft_nonsystem_includedirs),' ') +' \\\n')
	if C_defines:
		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
	if C_assembly_preprocessing:
		LineList.append('\t -o $*.s -S -xc++ -pipe $<\n')
		LineList.append('\t'+C_assembly_preprocessing+'\n')
		LineList.append('\tas -o $*.o $*.s\n')
	else:
		LineList.append('\t -o $*.o -c -xc++ -pipe $<\n')
	if object_strip:
		LineList.append('\t'+object_strip+'\n')

def CoreCRules(LineList):
#	if C_hard_nonsystem_includedirs:
#		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_hard_nonsystem_includedirs),' ') +' -I- \\\n')
#	if C_soft_nonsystem_includedirs:
#		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_soft_nonsystem_includedirs),' ') +' \\\n')
	if C_defines:
		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
	if C_assembly_preprocessing:
		LineList.append('\t -o $*.s -S -xc -pipe $<\n')
		LineList.append('\t'+C_assembly_preprocessing+'\n')
		LineList.append('\tas -o $*.o $*.s\n')
	else:
		LineList.append('\t -o $*.o -c -xc -pipe $<\n')
	if object_strip:
		LineList.append('\t'+object_strip+'\n')

def MakeMakefile():
	LineList = []	# makefile
	LineList2 = []	# dependencies

	# Makefile header
	LineList.append('# POSIX makefile\n')
	LineList.append('\n')
	LineList.append('.SUFFIXES:\n')
	if C_enabled:
		LineList.append('.SUFFIXES: '+CPP_suffix+' .c .o .exe\n')
	else:
		LineList.append('.SUFFIXES: '+CPP_suffix+' .o .exe\n')
	LineList.append('\n')

	LineList.append("include POSIX.inc\n")
	LineList.append('\n')

	# body of makefile
	LineList.append('# GNU targets we know about\n')
	LineList.append('all: '+join(map(lambda x: x+'.exe',MainPrograms),' ')+'\n')
	LineList.append('\n')

	LineList.append('clean:\n')
	LineList.append('\trm -f *.o *.exe'+extra_clean+'\n')
	LineList.append('\n')

	LineList.append('# dependencies\n')
	LineList.append('include POSIX.dep\n\n')

	if extra_targets:
		LineList.append(extra_targets)

	# target spec (must attempt to make most recently altered files first)
	for ProgName in ProgObjects.keys():
		LineList2.append('OBJECTS_'+ProgName.upper()+' = '+join(map(lambda x: x+'.o',ProgObjects[ProgName]),' ')+'\n')
		ObjfileListBase = map(lambda x: (x,stat(x+(CPP_suffix if isfile(x+CPP_suffix) else '.c'))[8]),ProgObjects[ProgName])
		ObjfileListBase.sort(lambda x,y : -cmp(x[1],y[1]))
		LineList2.append('OBJECTS_'+ProgName.upper()+'_LINK_PRIORITY = ' + join(map(lambda x: x[0] + '.o',ObjfileListBase),' ') + '\n\n')
		LineList.append(ProgName+'.exe :'+extra_prereqs+' $(OBJECTS_'+ProgName.upper()+'_LINK_PRIORITY)\n')
		if ProgName in CPP_override_libraries:
			LineList.append('\t'+CPP_compiler+' $(LINK_FLAGS) -o'+ProgName+'.exe $(OBJECTS_'+ProgName.upper()+') ' + CPP_override_libraries[ProgName] + '\n')
		else:
			LineList.append('\t'+CPP_compiler+' $(LINK_FLAGS) -o'+ProgName+'.exe $(OBJECTS_'+ProgName.upper()+') ' + CPP_libraries + '\n')
		LineList.append('\tstrip --preserve-dates --strip-unneeded '+ProgName+'.exe\n')
		LineList.append('\n')

#	dependency spec
	LineList2.append('# dependencies\n')
	ObjDeps = {}
	for ProgName in ProgObjects.keys():
		for Idx in ProgObjects[ProgName]:
			if Idx in ObjDeps:
				continue
			local_headers = ExtractHeaders(Idx+(CPP_suffix if isfile(Idx+CPP_suffix) else '.c'))
			ObjDeps[Idx] = 1
			if local_headers:
				LineList2.append(Idx+'.o: '+join(local_headers,' ')+'\n')
			else:
				LineList2.append('# '+Idx+'.o: \n')				

	# Makefile trailer
	LineList.append('# inference rules\n')
	if C_hard_nonsystem_includedirs:
		LineList.append('# local project search paths for headers\n')
	if C_soft_nonsystem_includedirs:
		LineList.append('# global project search paths for headers\n')
	if C_defines:
		LineList.append('# defines\n')
	LineList.append('# processing details\n')

	if CPP_suffix:
		LineList.append(CPP_suffix+'.o:\n')
		LineList.append('\t$(CXX) $(CFLAGS) $(CXXFLAGS) $(ARCH_FLAGS) $(OTHER_INCLUDEDIR) $(C_MACROS) $(CXX_MACROS) \\\n')
		CoreCPPRules(LineList)

	if C_enabled:
		LineList.append('\n.c.o:\n')
		LineList.append('\t$(CC) $(CFLAGS) $(ARCH_FLAGS) $(OTHER_INCLUDEDIR) $(C_MACROS) \\\n')
		CoreCRules(LineList)
	
	TargetFile = open('Makefile','w')	# POSIX
	TargetFile.writelines(LineList)
	TargetFile.close()

	TargetFile = open('POSIX.dep','w')
	TargetFile.writelines(LineList2)
	TargetFile.close()

if __name__ == '__main__':
	MakeMakefile()

